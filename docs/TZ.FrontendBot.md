## Техническое задание: Telegram Frontend‑бот (MVP)

### 1. Цели проекта
- Обеспечить пользователю управление своими подписками на «услуги» (объекты подписки: другой Telegram‑бот, API и т.п.): просмотр, продление, история платежей, смена языка, FAQ и поддержка.
- Поддержать «спящий режим» сервиса при окончании подписки с минимальной функциональностью до оплаты.
- Обеспечить администратору (в боте) инструменты: рассылки, базовая статистика, поиск/просмотр пользователя и его подписок, ручное изменение подписок, запуск сервиса после активации подписки, пауза/возобновление сервиса с компенсацией времени подписки.

### 2. Область применения
- Этот файл описывает ТЗ для фронтенд‑бота на базе Aiogram v3 (Python), использующего i18n, интеграцию с Backend API, и платежный флоу через внешние платёжные сервисы (ЮKassa, PayPal, Cryptomus) через Backend API.
- Бот не хранит секреты платёжных провайдеров, а общается с Backend API.
- Термины: «бот» — данный фронтенд Telegram‑бот; «услуга» — объект подписки пользователя; термин «проект» не используется.

### 3. Языки и локализация
- Бот поддерживает RU и EN. Команда/кнопка «Смена языка» — мгновенный переключатель.
- Язык по умолчанию — из профиля пользователя в БД (если нет — RU). Выбор сохраняется.
- Все тексты ниже приводятся в двух версиях. Храним в i18n словарях по ключам. Пример ключей: `menu.main.title`, `subscriptions.list.title`, `payments.history.title`, и т.д.
- Плейсхолдеры унифицированы: используем `{until_date}`, `{minutes}`, `{date}`.

### 4. Навигация и меню
- Главный экран (Reply‑кнопки, 1 ряд по 2–3 кнопки, адаптивно):
  - «Подписки» / «Subscriptions»
  - «История платежей» / «Payment history»
  - «Смена языка» / «Language»
  - «Техподдержка» / «Support» (ссылка)
  - «FAQ»
- Везде предусмотрены кнопки «Назад» / «Back».
- Для списков используются Inline‑кнопки с пагинацией, если >10 элементов.
  - Пагинация: максимум 10 элементов на страницу. Нижняя панель: «◀️ {page}/{pages} ▶️», «Назад».
  - Текущая страница сохраняется в состоянии, «Назад» возвращает на ту же страницу.

### 5. Состояния бота (FSM)
- Хранилище состояний: Redis.
- Разделение пространств состояний:
  - UserSG:
    - `STATE_IDLE`: дефолтное состояние, главное меню
    - `STATE_SUBSCRIPTIONS_LIST`: просмотр списка подписок
    - `STATE_SUBSCRIPTION_DETAIL`: просмотр конкретной подписки
    - `STATE_PAYMENT_METHOD_SELECT`: выбор платёжного провайдера/плана
    - `STATE_PAYMENT_PENDING`: ожидание оплаты (до получения статуса от Backend API)
    - `STATE_PAYMENTS_HISTORY`: просмотр истории платежей
    - `STATE_PAYMENT_DETAIL`: просмотр детали платежа
  - AdminSG (доступ только администраторам по Telegram ID):
    - `STATE_ADMIN_MAIN`: главное меню админа
    - `STATE_ADMIN_BROADCAST`: настройка и рассылка
    - `STATE_ADMIN_USER_SEARCH`: поиск пользователя
    - `STATE_ADMIN_USER_EDIT`: редактор пользователя/подписок
    - `STATE_ADMIN_SERVICES`: список сервисов
    - `STATE_ADMIN_SERVICE_DETAIL`: информация и управление сервисом
- Кеш навигации (Redis): отдельные ключи для страниц списков (`subscriptions_page`, `payments_page` и т.п.). При возврате в главное меню страницы сбрасываются. TTL для этих ключей — без ограничения.

### 6. Тексты (RU/EN)
- Главный экран:
  - RU: «Главное меню. Выберите действие.»
  - EN: "Main menu. Choose an action."
- Подписки — список:
  - RU: "Список текущих подписок.\n\nНажмите на подписку для управления"
  - EN: "Your active subscriptions.\n\nTap a subscription to manage"
- Подписка — карточка:
  - RU: "Название услуги: {service_name}\nПодписка активна: {until_date|Нет}"
  - EN: "Service name: {service_name}\nSubscription active: {until_date|No}"
- Кнопки в карточке подписки:
  - RU: «Продлить подписку», «Назад»
  - EN: "Renew", "Back"
- Выбор провайдера/плана:
  - RU: "Выберите способ оплаты и период"
  - EN: "Choose payment method and period"
- Ожидание оплаты:
  - RU: "Мы создали счёт. Оплатите его в течение {minutes} минут. После оплаты статус обновится автоматически."
  - EN: "Invoice created. Please pay within {minutes} minutes. Status will update automatically after payment."
- Оплата успешна:
  - RU: "Оплата получена. Подписка активна до {until_date}."
  - EN: "Payment received. Subscription is active until {until_date}."
- Оплата неуспешна/отменена/истекла:
  - RU: "Оплата не завершена. Попробуйте снова или выберите другой способ."
  - EN: "Payment not completed. Try again or choose a different method."
- История платежей — список:
  - RU: "История платежей (последние {n}). Выберите платеж для подробностей."
  - EN: "Payment history (last {n}). Choose a payment for details."
- Детали платежа:
  - RU: "Платёж {payment_id}\nПровайдер: {provider}\nСумма: {amount} {currency}\nСтатус: {status}\nДата: {date}\nОписание: {description|—}\nВнешний ID: {external_id|—}"
  - EN: "Payment {payment_id}\nProvider: {provider}\nAmount: {amount} {currency}\nStatus: {status}\nDate: {date}\nDescription: {description|—}\nExternal ID: {external_id|—}"
- Смена языка:
  - RU: "Язык переключен на русский."
  - EN: "Language switched to English."
- Поддержка:
  - RU: "По вопросам — {support_link}"
  - EN: "Support — {support_link}"
- FAQ:
  - RU: одноэкранный текст (до 1500 символов) + «Назад»
  - EN: same
- Оферта (PDF):
  - RU: «Нажмите, чтобы получить оферту (PDF)»
  - EN: "Tap to get the Terms (PDF)"

Примечание: конкретные тексты FAQ и оферты поставляются из Backend API (конфигурация проекта), бот их отображает/отдаёт документом.

### 7. Кнопки и callback‑данные
- Главные кнопки — ReplyKeyboardMarkup, остальные — InlineKeyboardMarkup.
- Формат callback‑данных: Aiogram v3 CallbackData/фабрики с короткими полями (напр. `t`, `p`, `id`). Для платежей в callback передаётся только `payment_id`; остальной контекст подтягивается из Backend API/БД.
- Примеры (семантика):
  - `subs_list(p=1)` — открыть список подписок, страница 1
  - `sub(id=123)` — открыть подписку id=123
  - `renew(id=123)` — начать продление подписки id=123
  - `pay(id=PAYMENT_ID)` — открыть/проверить платёж
  - `ph(p=1)` — история платежей, страница 1
  - `pd(id=987)` — деталь платежа
  - `back(to=main)` — назад в главное

### 8. Интеграция с Backend API (контракты бота)
- Авторизация: бот вызывает Backend API с сервисным токеном из env.
- Идентификатор пользователя: Telegram ID (далее `tg_id`). Все пользовательские эндпоинты используют `tg_id`.
- Бот не взаимодействует напрямую с платёжными провайдерами. Провайдерские вебхуки принимает Backend API и уведомляет бота об изменении статуса платежа (push‑уведомление из Backend API). Активный polling со стороны бота не используется.
- Эндпоинты (минимальные контракты):
  - `GET /users/{tg_id}` → `{ tg_id: int, language: "ru"|"en", used_bot_before: bool }`
  - `POST /users/{tg_id}/language` body `{ language: "ru"|"en" }` → `204`
  - `GET /users/{tg_id}/subscriptions?page=1` → `{ items: [ { id, service_id, service_name, status: "active"|"expired"|"paused", until_date: ISO8601|null } ], page, pages }`
  - `GET /subscriptions/{id}` → `{ id, service_id, service_name, status, until_date }`
  - `GET /services/{service_id}/payment-options` → `{ providers: ["yookassa"|"paypal"|"cryptomus"], plans: [ { code: "m1"|"m3"|"m6"|"y1", amount: number, currency: "RUB"|"USD"|... } ] }` (набор планов/цен конфигурируется администратором в Backend API)
  - `POST /payments` body `{ tg_id: int, service_id: int, plan: "m1"|"m3"|"m6"|"y1", provider: string }` → `{ payment_id: string, pay_link?: string, qr?: string, instructions?: string, expires_at: ISO8601 }`
  - `GET /users/{tg_id}/payments?page=1` → `{ items: [ { id, provider, amount, currency, status, date, description?, external_id? } ], page, pages }`
  - `GET /payments/{id}` → `{ id, provider, amount, currency, status, date, description?, external_id? }`
  - Админ (минимум):
    - `GET /admin/users/search?q=...` → список пользователей
    - `GET /admin/users/{tg_id}` → профиль, подписки, последние платежи
    - `POST /admin/subscriptions/{id}/extend` body `{ plan }` → продление
    - `POST /admin/subscriptions` body `{ tg_id, service_id, plan, until_date? }` → создать/изменить
    - `POST /admin/services/{id}/start` → запуск сервиса при активации подписки
    - `POST /admin/services/{id}/pause` → пауза сервиса (Backend API фиксирует `paused_at` и «замораживает» ход времени подписок)
    - `POST /admin/services/{id}/resume` → возобновление сервиса (Backend API рассчитывает новую `until_date` каждой активной подписки: `new_until = now + remaining_frozen_time`)
    - (по MVP) возвраты, сложная статистика и управление провайдерами — вне объёма

- Уведомления от Backend API к боту об изменении статуса платежа:
  - Внутренний webhook бота: `POST /internal/payments/notify`
  - Авторизация: заголовок `X-Internal-Token: <BOT_INTERNAL_WEBHOOK_TOKEN>`
  - Тело: `{ payment_id: string, status: "created"|"pending"|"paid"|"failed"|"canceled"|"refunded"|"chargeback" }`
  - Действия бота: обновить экран ожидания оплаты для пользователя; при `paid` — показать успех и вернуться в карточку подписки.

### 9. Пользовательские флоу
9.1. Первый вход
  - Бот проверяет `used_bot_before`. Если False — показывает приветствие (RU/EN) с коротким туром: где подписки, как продлить, где поддержка.
  - Ставим `used_bot_before=True`.

9.2. Подписки → Список
  - Запрос к API: `GET /users/{tg_id}/subscriptions?page=1`
  - Формируем список: каждая строка: `[Название (усечённо до 10 символов, 3 точки если нужно больше)… | Тип: Закрытый клуб/...]` + кнопка «Назад».
  - Пагинация «◀️/▶️» при необходимости, если элементов больше 10.

9.3. Подписка → Деталь
  - Запрос: `GET /subscriptions/{id}`
  - Вывод: название, статус, дата окончания/нет.
  - Кнопки: «Продлить подписку», «Назад».

9.4. Продление → Выбор провайдера/плана
  - Запрос: `GET /services/{service_id}/payment-options`
  - API возвращает: список провайдеров и планы: m1, m3, m6, y1 с ценами и валютой. Рекуррентные платежи — вне MVP.
  - Пользователь выбирает провайдера и план.
  - Бот вызывает: `POST /payments` с `{tg_id, service_id, plan, provider}`.
  - Ответ: `{payment_id, pay_link|qr|instructions, expires_at}`. Бот показывает кнопку «Открыть счёт» и «Проверить статус».
  - Автообновление статуса: по push‑уведомлению от Backend API (после вебхука провайдера). Polling ботом не используется.
  - При успехе: показать «Оплата получена…» и обновлённую дату подписки.
  - При неуспехе/истечении: «Оплата не завершена…» с возможностью повтора или смены метода.

9.4.1. Последовательность сообщений при оплате (полный сценарий)
1) Пользователь нажал «Продлить подписку» → бот: RU «Выберите способ оплаты и период», EN "Choose payment method and period" + список провайдеров и планов.
2) Пользователь выбрал провайдера/план → бот вызывает API `POST /payments` → отвечает сообщением:
   - RU: «Мы создали счёт. Нажмите «Открыть счёт», оплатите в течение {minutes} минут.»
   - EN: "Invoice created. Tap "Open invoice" and pay within {minutes} minutes."
   + кнопки: «Открыть счёт», «Проверить статус», «Отмена».
3) При нажатии «Открыть счёт» — открывается внешняя ссылка/инвойс. Бот остаётся в `STATE_PAYMENT_PENDING` и ожидает push от Backend API об изменении статуса. Пользователь может вручную нажать «Проверить статус».
4) При успехе (API → paid):
   - RU: «Оплата получена. Подписка активна до {date}.» + «Назад»
   - EN: "Payment received. Subscription is active until {date}." + "Back"
   - Возврат в карточку подписки с обновлёнными данными.
5) При неуспехе/истечении:
   - RU: «Оплата не завершена. Попробуйте снова или выберите другой способ.»
   - EN: "Payment not completed. Try again or choose a different method."
   - Кнопки: «Повторить», «Сменить способ», «Назад».

9.4.2. Оферта (PDF) в оплате
- На экране выбора провайдера/плана показывать Inline‑кнопку: RU «Оферта (PDF)», EN "Terms (PDF)". Нажатие — бот отправляет локальный PDF‑файл оферты из каталога `assets/offers`.


9.5. История платежей
  - Запрос: `GET /users/{tg_id}/payments?page=1` (10 на страницу, сортировка по дате убыв.)
  - Элемент списка: `{date} — {amount}{currency} — {provider} — {status_human}`. Нажатие → деталь `GET /payments/{id}`.
  - Формат даты: RU `ДД.ММ.ГГГГ HH:MM`, EN `YYYY‑MM‑DD HH:MM` (локаль пользователя, TZ — `UTC`).

9.6. Смена языка
  - Переключение RU/EN. `POST /users/{tg_id}/language`.

9.7. Техподдержка
  - Ответ‑сообщение с кликабельной ссылкой (из конфигурации услуги/сервиса).

9.8. FAQ
  - Запрос: `GET /services/{id}/faq` → текст + «Назад».

9.9. Оферта (PDF)
  - Inline‑кнопка «Оферта (PDF)» в карточке подписки и/или в FAQ.
  - Бот отправляет локальный PDF‑файл оферты из каталога `assets/offers`.

### 10. «Спящий режим» услуги
- Если подписка пользователя на услугу истекла:
  - При попытке взаимодействия с услугой (в клиентском боте услуги) — показывается короткое сообщение с предложением продлить.
  - Во фронтенд‑боте — карточка подписки отображается со статусом «Нет» и кнопкой «Продлить».
- Пауза услуги (админом):
  - Статус услуги: «Пауза». Кнопка оплаты для пользователя остаётся доступной; оплаченные продления накапливают время.
  - Компенсация времени: Backend API фиксирует `paused_at` и «замораживает» ход времени подписок (сохраняет оставшееся время на момент паузы). При «Возобновить» вычисляется новая дата окончания: `new_until = now + remaining_frozen_time (+ оплаченные расширения)`.

### 11. Уведомления и напоминания
- Настраиваются на Backend API; бот — только отображает.
- Стандарт: T‑3, T‑1, T‑0 (дата окончания) — ЛС пользователю: «Подписка заканчивается…» с кнопкой «Продлить». Язык уведомлений — текущий язык пользователя.
- При нажатии «Продлить» из уведомления бот переводит пользователя сразу в флоу продления нужной подписки (обновляет контекст в Redis), без deep‑link payload.

### 12. Админ‑функции в боте
Доступ только администраторам (список Telegram ID в конфиге).

- Команды и вход:
  - Для администратора `/start` показывает те же элементы, что и обычному пользователю, плюс кнопку «Админ‑панель» в Reply‑клавиатуре.

- Меню админа (MVP):
  - «Рассылка»: ввод текста (до 3500 символов), выбор сегмента (`all`, `active_subs`, `no_active_subs`, `service:<id>`), предпросмотр (только админу), подтверждение «Отправить всем? Да/Нет».
    - Ограничение скорости: до 20 сообщений/сек (безопасный запас от лимита Telegram 30/сек). Отчёт: `delivered`, `failed`, `skipped`.
    - Медиа — вне MVP (текст‑только).
  - «Статистика» — базовая: пользователи (всего/активные), активные подписки, месячный доход (сумма цен активных месячных подписок). Источник — Backend API.
  - «Пользователи» — поиск по @username, `tg_id` или части имени → карточка: язык, список подписок, последние платежи.
    - Действия: «Продлить», «Изменить подписку» (создать/изменить), при активации подписки — триггер `POST /admin/services/{id}/start`.
  - «Сервисы» — список услуг/сервисов со статусами (Запущена/Пауза/Остановлена/Ошибка) — опционально, в упрощённом виде.
    - Действия: «Запустить», «Пауза», «Возобновить», «Остановить», «Обновить конфигурацию» — соответствующие вызовы Backend API.

Все критические действия требуют подтверждения «Да/Нет».

### 13. Ошибки и UX‑детали
- Все сетевые ошибки показываются дружелюбно: RU «Сервис недоступен, попробуйте позже», EN "Service unavailable, try later".
- Просроченные счета отображаются с подсказкой повторить/сменить метод.
- Кнопка «Назад» всегда возвращает на предыдущий уровень без сброса контекста.
- Команды: `/start`, `/menu`, `/lang`, `/admin` (для админов).
  - `/start` всегда возвращает в главное меню. «Зависшие» оплаты не сбрасываются ботом; их статус обновит Backend API по вебхуку.

-### 14. Нефункциональные требования
- Производительность: ответы ≤ 1.5 сек при нормальной нагрузке (ожидаемо 0.3–0.5 сек на локальной БД).
- Надёжность: ретраи только для идемпотентных запросов (GET) с экспоненциальным backoff; для `POST /payments` — без ретраев (или с idempotency‑key — вне MVP).
- Обработка 429 (rate limit) от Backend: уважать заголовок `Retry-After` (секунды); повтор через указанный интервал, максимум 2 повтора. При отсутствии заголовка — backoff 0.5s, 1.5s.
- Логирование: входящие апдейты, ключевые события (создание платежа, статус оплаты). Не логировать чувствительные данные; `payment_id` — для корреляции.
- Безопасность: все запросы к Backend API — с сервисным токеном; токены платёжных провайдеров в боте не храним.

### 15. Конфигурация бота
- Через `.env` и YAML‑конфиг (см. README):
  - BOT_TOKEN
  - BACKEND_API_BASE_URL
  - BACKEND_API_TOKEN
  - SUPPORT_LINK (fallback; приоритет за конфигурацией сервиса из API)
  - DEFAULT_LANGUAGE
  - TIMEZONE=UTC (вывод дат в RU/EN — с пометкой UTC при необходимости)
  - FSM_STORAGE_URL (Redis)
  - ADMIN_USER_IDS (список Telegram ID через запятую; по MVP — один ID)
  - HTTPX_TIMEOUTS: CONNECT=2s, READ=5s, WRITE=5s, POOL=10s (переопределяемо)
  - BOT_INTERNAL_WEBHOOK_TOKEN (секрет для внутренних вызовов Backend API → бот)
  - INTERNAL_WEBHOOK_PATH=/internal/payments/notify (путь для внутренних уведомлений)
  - OFFERS_DIR=assets/offers (каталог с локальными PDF офертами; соглашение по имени файла: `service_<service_id>.pdf`)
  - INTERNAL_SERVER_HOST=0.0.0.0 (хост встроенного HTTP‑сервера для внутренних уведомлений)
  - INTERNAL_SERVER_PORT=8080 (порт встроенного HTTP‑сервера)
  - REDIS_KEY_PREFIX=clubifybot: (префикс для всех ключей в Redis)
  - TELEGRAM_DELIVERY_RPS=20 (целевой лимит отправки сообщений/сек при рассылках)
  - BROADCAST_BATCH_SIZE=1000 (размер пакета tg_id при выборке получателей из Backend API)
  - USE_LONG_POLLING=true (по умолчанию long polling; webhook вне MVP)
  - IDEMPOTENCY_ENABLED=true (включает заголовок `Idempotency-Key` для `POST /payments`)

### 16. Тестирование (MVP)
- Юнит‑тесты: роутеры, i18n переключение, форматирование сообщений.
- Интеграционные: мок Backend API для флоу продления и истории платежей.
- Регрессионные сценарии: отмена/истечение счёта, недоступный провайдер, отсутствие push по оплате (ручная проверка статуса).

### 17. Ограничения MVP
- Оплата инициируется через Backend API, который инкапсулирует логику провайдеров. Бот не делает прямых вызовов в платёжки.
- Рекуррентные платежи и грейс‑период — вне MVP.
- Автообновление статуса — через push от Backend API (после вебхука провайдера). Активный polling ботом — не используется.

### 18. Отображение статусов
- Подписка: `active`, `expired`, `paused` (используется для админских изменений подписки; редко).
- Услуга/сервис (глобально): `running`, `paused`, `stopped`, `error`.
  - В UI при `service.paused` показывать «Услуга на паузе администратором»; кнопка оплаты остаётся.
- Платёж (внутренние статусы): `created`, `pending`, `paid`, `failed`, `canceled`, `refunded`, `chargeback`.
  - Отображение для пользователя: `created/pending` → «Ожидание», `paid` → «Оплачен», `failed/canceled` → «Не завершён», `refunded` → «Возврат», `chargeback` → «Чарджбэк».
  - RU/EN‑лейблы соответствуют этой маппе.

### 19. Сценарии локализации текстов
- Все тексты вынесены в i18n словари с нейтральными плейсхолдерами.
- Дата форматируется в соответствии с языком: RU `ДД.ММ.ГГГГ`, EN `YYYY‑MM‑DD`; время — `HH:MM`; часовой пояс — `UTC`.

### 20. Телеметрия
- Отправка событий в Backend API: `bot.event` (тип, tg_id, payload) — для статистики.

### 21. Примеры сообщений (фрагменты i18n)
```
menu.main.title:
  ru: "Главное меню. Выберите действие."
  en: "Main menu. Choose an action."
subscriptions.list.title:
  ru: "Список текущих подписок.\n\nНажмите на подписку для управления"
  en: "Your active subscriptions.\n\nTap a subscription to manage"
subscription.detail.title:
  ru: "Название сервиса: {service_name}\nПодписка активна: {until_date}"
  en: "Service name: {service_name}\nSubscription active: {until_date}"
payment.waiting:
  ru: "Мы создали счёт. Оплатите его в течение {minutes} минут."
  en: "Invoice created. Please pay within {minutes} minutes."
payment.success:
  ru: "Оплата получена. Подписка активна до {date}."
  en: "Payment received. Subscription is active until {date}."
```

### 22. Совместимость
- Aiogram v3, Python 3.11+, httpx, pydantic, Redis (FSM storage). APScheduler не требуется (напоминания делает Backend API). Возможен запуск встроенного HTTP‑сервера (aiohttp/starlette) для приёма внутренних уведомлений от Backend API.

### 23. Границы ответственности
- Бот: UI/UX, FSM, локализация, безопасные вызовы API, отображение статусов и результатов.
- Backend API: бизнес‑логика, платежи, вебхуки, напоминания, управление сервисами, хранение данных.

### 24. Структура проекта (рекомендуемая)
- `src/`:
  - `bot/` — точка входа, конфиг, middlewares
  - `routers/` — `user.py`, `admin.py`, `subscriptions.py`, `payments.py`, `history.py`
  - `states/` — `user.py` (UserSG), `admin.py` (AdminSG)
  - `keyboards/` — фабрики Reply/Inline
  - `i18n/` — словари
  - `clients/` — HTTP‑клиент Backend API (httpx), схемы pydantic
  - `services/` — оркестрация флоу, маппинг статусов
  - `storage/` — Redis helpers (ключи страниц, контекст уведомлений)
  - `utils/` — форматирование дат/денег



### 25. Дополнения и обязательные уточнения (для закрытия вопросов реализации)

25.1. Контракты Backend API (дополнения к п.8)
- `PATCH /users/{tg_id}` → body `{ language?: "ru"|"en", used_bot_before?: bool }` → `204`.
- `GET /services/{id}` → `{ id, name, status: "running"|"paused"|"stopped"|"error" }`.
- `GET /admin/broadcast/recipients?segment=all|active_subs|no_active_subs|service:<id>&cursor=&limit=1000` → `{ items: number[], next_cursor?: string }` (возвращает список `tg_id` батчами; порядок не важен).
- `POST /events` → `{ type: string, tg_id: number, payload?: object, ts?: ISO8601 }` → `202` (асинхронная телеметрия; батчинг на стороне Backend опционален).
- Требование: в `GET /services/{service_id}/payment-options` все планы в одном ответе имеют единую валюту. Если не так — Backend возвращает 400.
- `POST /payments` поддерживает идемпотентность по заголовку `X-Idempotency-Key` (см. п.25.4). При повторе с тем же ключом должен возвращать тот же `{ payment_id, ... }`.

25.2. Внутренние уведомления (дополнения к п.12 и п.11)
- Встроенный HTTP‑сервер бота принимает:
  - `POST {INTERNAL_WEBHOOK_PATH}` (из п.8) — изменение статуса платежа: `{ payment_id: string, status: "created"|"pending"|"paid"|"failed"|"canceled"|"refunded"|"chargeback" }`.
  - `POST /internal/notifications/renew` — инициировать сообщение‑напоминание о продлении: body `{ tg_id: number, subscription_id: number }`.
- Авторизация: заголовок `X-Internal-Token: <BOT_INTERNAL_WEBHOOK_TOKEN>` обязателен. Повторные (дубликатные) вызовы допустимы; бот обязан быть идемпотентным.
- Сеть: сервер слушает `{INTERNAL_SERVER_HOST}:{INTERNAL_SERVER_PORT}`; доступ из Backend обязан быть настроен на уровне инфраструктуры (NAT/ingress).

25.3. Политика обновления UI по платежам
- На этапе `STATE_PAYMENT_PENDING` бот хранит в Redis `payment:<id>:message_id` и редактирует одно и то же сообщение при получении статусов. Если сообщение удалено/не найдено — отправляет новое и обновляет `message_id`.
- Неизвестный `payment_id` (нет контекста в Redis): бот запрашивает `GET /payments/{id}` и отправляет пользователю лаконичное сообщение со статусом и ссылкой «Назад в подписку», если возможно.
- Гонки статусов (push и ручная проверка): применяем «последний по времени» статус. При равных — приоритет по порядку: `paid > refunded > chargeback > failed/canceled > pending/created`.

25.4. Идемпотентность и параллельные оплаты
- Бот отправляет заголовок `X-Idempotency-Key` в `POST /payments`. Значение — UUIDv4 на одну попытку создания счёта. При нажатии «Повторить» создаётся новый ключ.
- Разрешён только один активный счёт на одну подписку на пользователя. Пока по этой подписке есть статус `created/pending`, кнопка «Создать новый счёт» скрыта; доступны «Проверить статус», «Отмена», «Назад».
- «Отмена» очищает контекст оплаты в Redis (ключи `payment:*` для данной подписки) и возвращает в карточку подписки.

25.5. Пагинация
- Фиксированный размер страницы: 10 элементов (подписки, платежи). Поле `page` — 1‑based. Поле `pages` ≥ 1.
- Если запрошенная страница вне диапазона, Backend возвращает `{ items: [], page: <запрошенная>, pages: <фактическое> }`; бот клипует страницу в границы.
- Пагинационные состояния (`subscriptions_page`, `payments_page`) хранятся в Redis без TTL; очищаются при возврате в главное меню.

25.6. Форматирование, i18n, вёрстка текстов
- Деньги: вывод `<amount> <currency>`, десятичные знаки по валюте (2 для RUB/USD/EUR). Разделитель — точка; тысячные не разделяем.
- Даты/время: все даты в `UTC`. Формулы форматирования из п.9.5 обязательны; если нужно показать таймзону — добавляем `UTC` суффиксом.
- Усечение названий: до 10 графем Unicode; многоточие — символ `…`.
- Маппинг статусов (п.18) выполняется на стороне бота через i18n‑ключи; Backend отдаёт машинные статусы.

25.7. Платёжный флоу (детализация)
- Ответ `POST /payments` может включать поля в любых комбинациях: `pay_link` (URL), `qr_url` (URL на PNG‑QR), `instructions` (plain‑text). Бот показывает всё доступное: кнопку «Открыть счёт», при наличии `qr_url` — отправляет изображение с подписью.
- `expires_at`: для текста `{minutes}` считаем `ceil((expires_at - now_utc)/60)`. Если ≤0 — считаем счёт истёкшим и показываем соответствующий экран с кнопками «Повторить», «Сменить способ», «Назад».
- Дублирование оплат: бот никак не аггрегирует; финальная логика — на Backend. При статусе `paid` — всегда показывает успех и актуальную `until_date` из карточки подписки (после рефреша `GET /subscriptions/{id}`).
- Провайдер‑специфика (MVP): основной UX — открытие внешней инвойс‑страницы по `pay_link` (YooKassa/PayPal/Cryptomus). `qr_url` может отсутствовать; бот не генерирует QR сам.

25.8. История платежей
- `description` и `external_id` могут отсутствовать; в UI используем плейсхолны из п.6.
- При открытии детали платежа бот всегда делает свежий `GET /payments/{id}`.

25.9. Админ‑функции (рассылка, статистика, пользователи)
- Рассылка: бот запрашивает получателей батчами через `GET /admin/broadcast/recipients` с `limit=BROADCAST_BATCH_SIZE` и `cursor`. Отправка с лимитом `TELEGRAM_DELIVERY_RPS`, с экспоненциальным backoff при 429/ FloodWait. Повторы для `failed` до 3 раз. Итоговый отчёт админу: `delivered`, `failed`, `skipped`.
- Предпросмотр: черновик хранится в Redis (`broadcast:<admin_tg_id>:draft`), переписывается при повторном вводе.
- Статистика: «месячный доход» трактуется как MRR (нормализация: `m3=amount/3`, `m6=amount/6`, `y1=amount/12`) по активным подпискам на момент запроса.
- Продление/изменение подписки из админ‑карточки: админ выбирает `plan` из `payment-options`; подтверждение обязательно.

25.10. Ошибки и UX
- Единое дружелюбное сообщение для сетевых сбоёв (п.13) + контекстные подсказки (кнопка «Повторить» если операция идемпотентна).
- Ретраи GET‑запросов: до 2 попыток с backoff 200ms, 600ms. POST без ретраев, кроме `POST /payments` (полагаться на идемпотентность Backend).
- Если редактируемое сообщение удалено/устарело — отправляем новое; UX не должен зависать.
- Callback‑данные ограничиваются ≤ 40 байт; используем фабрики с короткими ключами (`t`, `p`, `id`).

25.11. Ассеты и контент
- Оферта: если файла `assets/offers/service_<service_id>.pdf` нет — бот отправляет сообщение: RU «Оферта недоступна», EN "Terms unavailable" + `SUPPORT_LINK`.
- Максимальные размеры Telegram соблюдаются по умолчанию; специальные оптимизации не требуются в MVP.

25.12. Безопасность и приватность
- Логи: структурированные JSON, уровни INFO/ERROR. Поля для корреляции: `tg_id`, `payment_id`, `request_id` (генерируется). PII не логируем сверх этого. Ретеншн логов — 14 дней.
- Секреты (`BACKEND_API_TOKEN`, `BOT_INTERNAL_WEBHOOK_TOKEN`) — только из env; ротация вне объёма MVP, но поддерживается без рестарта (чтение при каждом запросе).
- Доступ к админке — только по whitelist `ADMIN_USER_IDS`.

25.13. Инфраструктура и развёртывание
- Обновления Telegram — long polling (webhook вне MVP). Встроенный HTTP‑сервер (п.25.2) обслуживает только внутренние уведомления.
- Масштабирование: для MVP — один инстанс бота. Redis общий. Позднее — потребуется координация для рассылок и дедуп событий.
- Таймауты httpx — как в п.15; для внутренних запросов Backend→бот — 2s connect/5s read рекомендуются.
- Наблюдаемость: метрики (количество апдейтов, ошибок, доставленных уведомлений), экспорт через логи; полноценный прометей — вне MVP.

25.14. Тестирование (детализация к п.16)
- Контрактные фикстуры для API (`users`, `subscriptions`, `payments`, `services`) — снапшоты JSON в репозитории тестов.
- Юнит‑снапшоты i18n‑строк и форматирования дат/денег; проверка наличия ключей и корректной подстановки плейсхолдеров.
- Интеграционный тест флоу оплаты: создание счёта → получение push `paid` → обновление карточки подписки.
- Негативные сценарии: отсутствие push (ручная «Проверить статус»), истёкший счёт (`expires_at` в прошлом), 429 при рассылке (backoff).

25.15. Навигация и состояния (детализация к п.5)
- «Назад»: реализуется стек состояний на пользователя (в Redis). Возврат из любого экрана ведёт к предыдущему экрану с сохранением пагинации и контекстов.
- Вход из уведомления «Продлить» складывает в стек только нужный контекст (`subscription_id`) и ведёт прямо в выбор провайдера/плана; «Назад» возвращает в карточку подписки.
- Сброс на `/start` очищает стек, но не отменяет активные оплаты; их статус обновится по push.

25.16. Deep‑links и уведомления о продлении
- Deep‑link payload не используется. Напоминания формирует Backend через `POST /internal/notifications/renew` (см. п.25.2), бот отправляет сообщение с кнопкой `renew(id=<subscription_id>)`.

25.17. Redis и ключи
- Именование: `{REDIS_KEY_PREFIX}<namespace>:<tg_id>[:extra]`. Примеры: `clubifybot:navstack:<tg_id>`, `clubifybot:subscriptions_page:<tg_id>`, `clubifybot:payment:<payment_id>:message_id`.
- TTL: навигация и страницы — без TTL; временные контексты (оплаты) — TTL 24 часа.
- Режим Redis: без eviction критических ключей (рекомендуется `noeviction` или достаточный объём памяти).

25.18. Ограничения Telegram
- Соблюдать лимиты: текст сообщения ≤ 4096 символов, callback data ≤ 64 байт (цель ≤ 40), кнопок в инлайн‑ряду ≤ 8.
- Ограничение отправок: таргет 20 сообщений/сек на инстанс (см. `TELEGRAM_DELIVERY_RPS`).

Эти уточнения являются обязательной частью MVP и считаются источником истины в случае расхождений с более ранними разделами.

